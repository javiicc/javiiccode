---
title: "Threading in Python"
subtitle: ""
description: ""
author: "Javier Casta√±o Candela"
date: "2024-01-30"
read_time: ""
last_update: ""
thumbnail: "/mediaArticles/threading-in-python/ex_8_four_threads_threading_lib.png"
tags: ["concurrence", "threading", "python"]
---

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_8_four_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 4 threads, 4 I/O-bound tasks of 1s and 4 CPU-bound tasks</p>
  </figcaption>
</figure>

This post is an introduction to threading in Python. The resources section at the end 
has some links to wonderful material that you can use to go deeper into the topic ü§ì

> üìò If you haven't yet, I would recommend you to read my article on 
> <a href="https://javiiccode.com/introduction-to-concurrence-and-parallelism" target="_blank">concurrence and 
> parallelism</a> to be clear about the concepts before reading this one.

<div className="resources font-semibold">
  <h5>Related posts:</h5>
  <ol>
    <li>
      <a
        href="https://javiiccode.com/introduction-to-concurrence-and-parallelism"
        target="_blank"
      >
        Introduction to Concurrence and Parallelism
      </a>
    </li>
    <li>
      <a
        href="https://javiiccode.com/multiprocessing-in-python"
        target="_blank"
      >
        Multiprocessing in Python
      </a>
    </li>
    <li>
      <a
        href="https://javiiccode.com/concurrence-in-python-with-async"
        target="_blank"
      >
        Concurrence in Python with Async
      </a>
    </li>
  </ol>
</div>

## What is a Thread

**A thread is the basic unit of execution within a process.** It is an independent 
flow of execution that shares the same address space as other independent flows of 
execution within the same process. A process can have one or more threads, one of 
them is the *main thread*, which is the default thread of a Python process. 

> üìò In Python we can use the 
> <a href="https://docs.python.org/3/library/threading.html" target="_blank">threading</a>
> module to write programs that use multiple threads, a well as the 
> 

If the developer writes the program so it makes use of several threads, then the program 
will be able to run concurrently in one core. It is also possible executing a one thread 
program concurrently by using coroutines (see 
<a href="https://javiiccode.com/concurrence-in-python-with-async" target="_blank">Async in Python</a>). 

The **threads within each Python (CPython implementation) process cannot run in parallel** 
even when multiple cores are available because of Python's Global Interpreter Lock (GIL), 
unlike threads in other programming languages such as Java, C/C++, and Go. If you have 
CPU-bound operations and need parallel implementation in Python you should use the 
<a href="https://docs.python.org/3/library/multiprocessing.html" target="_blank">multiprocessing</a> 
module (see <a href="https://javiiccode.com/multiprocessing-in-python" target="_blank">Multiprocessing in 
Python</a>).

Imagine that the developer writes a program that will become a single process when it starts 
execution. Also, the process will have two threads. When there are two threads it is possible 
to start playing with concurrence. 

In a single-core CPU it is possible for the program to execute concurrently. With one core and two threads, 
the threads can be switched one for the other in the same core. That is called **context switching**. 

During a **context switch**, one thread is switched out of the CPU so another thread can run.
For this purpose, the state of the process or thread is stored, so that it can be restored and resume 
execution at a later point, and then another previously saved state is restored. 

Context switching is usually computationally expensive, switching from one process or 
thread to another requires a certain amount of time for saving and loading registers and other 
operations. Switch context between threads is generally faster than between processes.

## Thread Life-Cycle

## Threading use cases

**The cases where multithreading is best suited for use are I/O-bound operations**. 
For example, if a thread executes an instruction that has to make a request to a 
database, it would not make sense to block the CPU core with a thread waiting for 
a response. Instead, it would be a better use of resources to allow another thread 
to use the core while the first thread is waiting.

In the figure below the empty circles represent I/O operations where the thread keeps 
waiting for something to occur. When the first I/O operation begins (empty green 
circle) **the operative system quickly switch the waiting thread** for the red one 
in order to better allocate computational resources. This is a decision taken by 
the **OS**, the developer cannot decide when to switch between threads.

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/concurrent-execution-io-bound.png"
    alt="Concurrent execution of tasks with I/O-bound operations"
  ></img>
  <figcaption>
    <p>Concurrent execution of tasks with I/O-bound operations</p>
  </figcaption>
</figure>

If the program does not use multiples threads running concurrently and instead it 
runs tasks within a single thread sequentially, it would need to wait for the green 
task to complete to begins the execution of the red task, so it would spend more time 
to complete both tasks.

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/sequential-execution-io-bound.png"
    alt="Sequential execution of tasks with I/O-bound operations"
  ></img>
  <figcaption>
    <p>Sequential execution of tasks with I/O-bound operations</p>
  </figcaption>
</figure>

So when dealing with I/O operations multithreading is a good choice to achieve a better allocation 
of resources.

Now let's see some implementations of multithreaded programs! ü•∑üèΩ

## Python threading first steps

First let's define the I/O-bound and the CPU-bound tasks. The `io_bound_operation` 
just sleeps as long as the number of seconds specified. The `cpu_bound_operation` 
adds the range of numbers specified. Both functions append the results to the 
`shared_list`. Remember that threads in the same process can share data.

```python {20, 23, 30-31, 34} showLineNumbers
import logging
from threading import Thread
from time import perf_counter, sleep

from concurrence.utils import flaten_list_of_lists, get_saving_path, postprocess_times
from concurrence.visualize import barh


format = "%(asctime)s: %(message)s"
logging.basicConfig(format=format, level=logging.INFO, datefmt="%H:%M:%S")


shared_list = []  # threads from the same process share data


def io_bound_operation(secs: float | int) -> None:
    """Run 1 I/O-bound task of secs seconds and append the results to
    shared_list."""
    start = perf_counter()
    sleep(secs)
    finish = perf_counter()

    shared_list.append([(start, finish)])


def cpu_bound_operation(n: int) -> None:
    """CPU-bound task."""
    start = perf_counter()
    count = 0
    for i in range(n):
        count += i
    finish = perf_counter()

    shared_list.append([(start, finish)])
```

Now we are going to create two new threads: `t1` and `t2`. When 
instantiating the `Thread` object, we need to add the `target`, which 
is the task/function we want to run in the thread. Arguments can be 
passed via the `args` parameter, which accepts an Iterable object.

For this example, we will make the **I/O-bound** operation last for **1 second**, 
while my processor takes approximately **3.5 seconds** to add those 
**100,000,000 numbers**.

```python {3, 4} showLineNumbers
def threading_two_threads():
    # Create two thread objects
    t1 = Thread(target=io_bound_operation, args=(1,))
    t2 = Thread(target=cpu_bound_operation, args=(100000000,))

    # Start activity -> invokes run() method
    t1.start()
    sleep(0.1)
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads
    # being finished
    t1.join()
    t2.join()

    logging.info(f"shared_list {shared_list}")
```

Then we need to start the thread's activity. This is done by calling 
the `start()` method. It arranges for the object's `run()` method to be 
invoked in a separate thread of control.

Also, there is a `sleep(0.1)` function to make the second thread start a 
bit later. It will help us to better visualize.

```python {7, 9} showLineNumbers
def threading_two_threads():
    # Create two thread objects
    t1 = Thread(target=io_bound_operation, args=(1,))
    t2 = Thread(target=cpu_bound_operation, args=(100000000,))

    # Start activity -> invokes run() method
    t1.start()
    sleep(0.1)
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads
    # being finished
    t1.join()
    t2.join()

    logging.info(f"shared_list {shared_list}")
```

Finally, we must call the `Thread` object's `join()` method if we want 
to wait until the thread terminates. 

The **main thread** will not exit until both threads have completed. However, 
although the **main thread** will wait for the other threads to complete, it 
will continue its execution. 

By joining the threads we are blocking the **calling thread** (**main thread**) 
until the thread whose `join()` method is called terminates -- either normally 
or through an unhandled exception or until the optional timeout occurs.

You can play with this example, if you comment both `join()` methods the program 
will raise an exception, since there will be nothing in the `shared_list` and the 
`postprocess_times` function will try to index the empty list. 

```python {13, 14} showLineNumbers
def threading_two_threads():
    # Create two thread objects
    t1 = Thread(target=io_bound_operation, args=(1,))
    t2 = Thread(target=cpu_bound_operation, args=(100000000,))

    # Start activity -> invokes run() method
    t1.start()
    sleep(0.1)
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads
    # being finished
    t1.join()
    t2.join()

    logging.info(f"shared_list {shared_list}")
```

In order to visualize the time spent by the threads the `threading_two_threads` 
function has a couple of additional functions to postprocess and plot them on 
the horizontal bar chart. The code can be found in the 
<a href="https://github.com/javiicc/concurrence-and-parallelism-python" target="_blank">repo</a>.

```python {19, 22-29} showLineNumbers
def threading_two_threads():
    # Create two thread objects
    t1 = Thread(target=io_bound_operation, args=(1,))
    t2 = Thread(target=cpu_bound_operation, args=(100000000,))

    # Start activity -> invokes run() method
    t1.start()
    sleep(0.1)
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads
    # being finished
    t1.join()
    t2.join()

    logging.info(f"shared_list {shared_list}")

    # Just some processing for chart
    start_points, end_points = postprocess_times(flaten_list_of_lists(shared_list))
    # start_points, end_points = postprocess_times(shared_list)

    barh(
        title="Concurrent execution, 2 threads, 1 I/O-bound task of 1s + 1 \
               CPU-task of 3.5s aprox",
        start_points=start_points,
        end_points=end_points,
        path=get_saving_path("threading/images/first_multithreaded_program.png"),
        n=2,
    )


if __name__ == "__main__":
    logging.info(f"Init concurrent tasks")
    threading_two_threads()
    logging.info(f"Finish concurrent tasks")
```

The image below shows the time spent by each thread to terminate. The `sleep` 
function makes the second thread (`cpu_bound_operation`) start a little later.
The first thread (0 in the graph) starts and 0.1 seconds later, the second one 
starts.

As the **I/O-bound** task only lasts for 1 second and the function `io_bound_operation` only 
has to do that operation, during the time that the **I/O-bound** task is waiting (the whole second) 
the **CPU-bound** task can be executing. That is why the **CPU-bound** task (second thread) 
only lasts 3.5 seconds approximately and is not delayed by the **I/O-bound** task.

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/first_multithreaded_program.png"
    alt="Times spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 2 threads, 1 I/O-bound task of 1s + 1 CPU-task of 3.5s aprox</p>
  </figcaption>
</figure>

The <a href="https://docs.python.org/3/library/threading.html#thread-objects" target="_blank">Thread</a> 
object is a naive way of creating threads, there are more convenient ways of doing it. 
However, let's look a some more simple examples before delving a little deeper.

## Visualizing multihreading times with threading module

### Example 1 - 2 threads

> Thread 1: 1 I/O-bound operation of 1s and 1 CPU-bound operation of 1s approx.
> 
> Thread 2 - 1 CPU-bound task of 3.5 seconds approximately

Now let's consider that the first thread runs a task consisting of 
a **CPU-bound** operation of approximately 1 second and an **I/O-bound** operation 
of 1 second instead of having a task that only executes an **I/O-bound** operation.

So now we have a program that creates two new threads, one running an **I/O-bound** operation 
and a **CPU-bound** operation and another running the **CPU-bound** operation of 3.5 seconds approximately.

```python {6-8} showLineNumbers
def cpu_io_bound_operations(secs: float | int, n: int) -> None:
    """Run 1 function that execute 1 I/O-bound task of secs seconds and 1 CPU-bound task.
    Append the results to shared_list."""
    start = perf_counter()
    count = 0
    for i in range(n):  # CPU-bound
        count += i
    sleep(secs)  # I/O-bound
    finish = perf_counter()

    shared_list.append([(start, finish)])
```

The thread 2 needs 3.5 seconds of processor approximately, while the thread 1 only needs 1 second.

The thread 1 only needs 1 second due to the **CPU-bound** operation, since the waiting time of 
the **I/O-bound** task can be used by the thread 2.

If we add 3.5s (thread 2) + 1s (thread 1) we have **4.5s** of CPU work.

The graph below shows just that, both tasks together last 4.5 seconds. The time required by 
each CPU-intensive task may vary slightly.

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/second_multithreaded_program.png"
    alt="Times spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 2 threads, (1 I/O-bound op of 1s and 1 CPU-bound op of 1s) + 1 CPU-task of 3.5s aprox</p>
  </figcaption>
</figure>

However, the thread 1 spends 3 seconds to terminate. That is because we don't control 
when context switches occur, so the thread 1 could have been waiting some time to use the processor, 
even when the **I/O-bound** was terminated. Context switches are out of developer's control, so they 
can occur more time than we actually would like and in moments we wouldn't switch one thread 
for the other.

Now let's take a quick look at some more examples! If you already got it you can skip this part and go 
directly to the next section üöÄ

### Example 2 - 1 thread

> 10 IO-bound operations of 1s sequentially

Here, we are representing a sequential execution and we don't need to create more threads, the 
main thread is enough.

```python {6} showLineNumbers
def sequential(n: int = 10, secs: float | int = 1) -> None:
    """Perform n I/O-bound operations of secs seconds sequentially in one thread
    and plot a horizontal bar chart.
    """
    # Perform n I/O-bound operations, save a tuple for each task
    times = [io_bound_operation(secs) for _ in range(n)]
    start_points, end_points = postprocess_times(times)

    barh(
        title="Sequential execution, 1 thread, 10 I/O-bound tasks of 1s",
        start_points=start_points,
        end_points=end_points,
        path=get_saving_path("threading/images/ex_1_one_thread.png"),
    )
```

In the figures above a thread was represented as a bar because each thread 
performed a task (even when we joined an **I/O-bound** and a **CPU-bound** operation 
we considered them as belonging to the same task).

Now we consider 10 different **I/O-bound** tasks executed in the same thread, so we 
can better visualize each task in a bar. So those ten bars belong o the same thread.

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_1_one_thread.png"
    alt="Time spent by single-thread program"
  ></img>
  <figcaption>
    <p>Times spent by single-thread program. 1 thread, 10 I/O-bound tasks of 1s</p>
  </figcaption>
</figure>

### Example 3 - 1 thread

> 2 CPU-bound tasks

If we execute two CPU-bound tasks of 3.5 seconds approximately in the 
same thread sequentially we see that they take about 7 seconds to complete.

Before the second task begins, the first one have to complete.

```python {3} showLineNumbers
def sequential(counts: int, n: int = 10) -> None:
    # Perform n CPU-bound operations, save a tuple for each task
    times = [cpu_bound_operation(counts) for _ in range(n)]
    start_points, end_points = postprocess_times(times)
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_5_one_thread.png"
    alt="Time spent by sequential program"
  ></img>
  <figcaption>
    <p>Times spent by single-thread program. 1 thread, 2 CPU-bound tasks of 3.5s aprox</p>
  </figcaption>
</figure>

### 2 threads, 1 CPU-bound tasks of 3.5s aprox each

The same two CPU-bound tasks from above show a very different chart when 
we execute them concurrently. Both tasks seem to take 7 seconds, but in 
reality they take 3.5. They just switch back and forth until they are 
both finished.

This is not a proper use of multithreading, it is only for didactic reasons. 
There is no time improvement using multithreading with only CPU-bound tasks.

```python {3, 8-9} showLineNumbers
def thread_cpu_bound_operations(counts: int) -> None:
    """Run a CPU-bound task and append the results to shared_list."""
    shared_list.append([cpu_bound_operation(counts)])


def threading_two_threads() -> None:
    # Create two thread objects, each thread will perform five I/O-bound tasks
    t1 = Thread(target=thread_cpu_bound_operations, args=(100000000,))
    t2 = Thread(target=thread_cpu_bound_operations, args=(100000000,))

    # Start activity -> invokes run() method
    t1.start()
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads being finished
    t1.join()
    t2.join()
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_6_two_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 2 threads, 1 CPU-bound tasks of 3.5s aprox each</p>
  </figcaption>
</figure>

### 2 threads - 5 IO-bound tasks of 1s each

Ten I/O-bound tasks of 1 second and two threads. Each thread is in charge of 
executing five I/O-bound tasks sequentially, and each group of five tasks are 
executed concurrently.

```python {3, 8-9} showLineNumbers
def thread_io_bound_operations(n: int, secs: float | int) -> None:
    """Run n I/O-bound tasks of secs seconds and append the results to shared_list."""
    shared_list.append([io_bound_operation(secs) for _ in range(n)])


def threading_two_threads() -> None:
    # Create two thread objects, each thread will perform five I/O-bound tasks
    t1 = Thread(target=thread_io_bound_operations, args=(5, 1))
    t2 = Thread(target=thread_io_bound_operations, args=(5, 1))

    # Start activity -> invokes run() method
    t1.start()
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads being finished
    t1.join()
    t2.join()
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_2_two_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 2 threads, 5 I/O-bound tasks of 1s each</p>
  </figcaption>
</figure>

### 10 threads - 1 IO-bound task of 1s each

Similar to the last example, but now we have ten threads instead of two, and each one 
is in charge of executing only one I/O-bound task of 1 second.

```python {3, 9-10} showLineNumbers
def thread_io_bound_operations(n: int, secs: float | int) -> None:
    """Run n I/O-bound tasks of secs seconds and append the results to shared_list."""
    shared_list.append([io_bound_operation(secs) for _ in range(n)])


def threading_two_threads() -> None:
    threads = []
    # Create ten thread objects, each thread will one I/O-bound tasks
    for _ in range(10):
        t = Thread(target=thread_io_bound_operations, args=(1, 1))
        t.start()
        threads.append(t)

    # Block the calling thread -> Avoids continuing to run without threads being finished
    [thread.join() for thread in threads]
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_3_ten_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 10 threads, 1 I/O-bound tasks of 1s each</p>
  </figcaption>
</figure>

### Thread 1 - 1 CPU-bound task - Thread 2 - 5 IO-bound tasks of 1s

Now we have two threads. The thread 1 executes one CPU-bound operation of 3.5 seconds 
approximately, and the thread 2 executes five I/O-bound tasks of 1 second. 

While the I/O tasks are waiting the CPU intensive task is executing, as every time an 
I/O task begins, the OS switches from one thread to the other very quickly.

```python {3, 8, 13-14} showLineNumbers
def thread_io_bound_operations(n: int, secs: float | int) -> None:
    """Run n I/O-bound tasks of secs seconds and append the results to shared_list."""
    shared_list.append([io_bound_operation(secs) for _ in range(n)])


def thread_cpu_bound_operations(counts: int) -> None:
    """Run a CPU-bound task and append the results to shared_list."""
    shared_list.append([cpu_bound_operation(counts)])


def threading_two_threads() -> None:
    # Create two thread objects, each thread will perform five I/O-bound tasks
    t1 = Thread(target=thread_cpu_bound_operations, args=(100000000,))
    t2 = Thread(target=thread_io_bound_operations, args=(5, 1))

    # Start activity -> invokes run() method
    t1.start()
    t2.start()

    # Block the calling thread -> Avoids continuing to run without threads being finished
    t1.join()
    t2.join()
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_4_two_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. Thread 1: 1 CPU-bound task of 3.5s aprox, Thread 2: 5 I/O-bound tasks of 1s</p>
  </figcaption>
</figure>

### 6 threads - 3 IO-bound tasks of 1s and 3 CPU-bound tasks

Here, we have three threads in charge of executing one I/O task each, and three 
threads in charge of executing one CPU intensive task each. The three CPU intensive 
tasks take different amounts of time to complete. 

The longest task, which last 3.5 seconds, is the first to begin (5). It takes almost 
6 seconds to complete due to the other two CPU intensive tasks.

```python {3, 8, 13-18} showLineNumbers
def thread_io_bound_operations(n: int, secs: float | int) -> None:
    """Run n I/O-bound tasks of secs seconds and append the results to shared_list."""
    shared_list.append([io_bound_operation(secs) for _ in range(n)])


def thread_cpu_bound_operations(counts: int) -> None:
    """Run a CPU-bound task and append the results to shared_list."""
    shared_list.append([cpu_bound_operation(counts)])


def threading_six_threads() -> None:
    # Create two thread objects, each thread will perform five I/O-bound tasks
    t1 = Thread(target=thread_cpu_bound_operations, args=(100000000,))
    t2 = Thread(target=thread_cpu_bound_operations, args=(50000000,))
    t3 = Thread(target=thread_cpu_bound_operations, args=(20000000,))
    t4 = Thread(target=thread_io_bound_operations, args=(1, 1))
    t5 = Thread(target=thread_io_bound_operations, args=(1, 1))
    t6 = Thread(target=thread_io_bound_operations, args=(1, 1))

    # Start activity -> invokes run() method
    t1.start()
    t2.start()
    t3.start()
    t4.start()
    t5.start()
    t6.start()

    # Block the calling thread -> Avoids continuing to run without threads being finished
    t1.join()
    t2.join()
    t3.join()
    t4.join()
    t5.join()
    t6.join()
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_7_six_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 6 threads, 3 I/O-bound tasks of 1s and 3 CPU-bound tasks</p>
  </figcaption>
</figure>

### 4 threads - 4 IO-bound tasks of 1s and 4 CPU-bound tasks

The thread 1 executes two CPU-bound operations of 3.5 seconds each sequentially (bars 6 and 7). 
The thread 2 executes two CPU-bound operations of almost 1 second each sequentially (bars 4 and 5). 

The other bars represent the I/O-bound tasks, two for each thread. 

```python {3, 8, 13-16} showLineNumbers
def thread_io_bound_operations(n: int, secs: float | int) -> None:
    """Run n I/O-bound tasks of secs seconds and append the results to shared_list."""
    shared_list.append([io_bound_operation(secs) for _ in range(n)])


def thread_cpu_bound_operations(counts: int, n: int) -> None:
    """Run a CPU-bound task and append the results to shared_list."""
    shared_list.append([cpu_bound_operation(counts) for _ in range(n)])


def threading_four_threads() -> None:
    # Create two thread objects, each thread will perform five I/O-bound tasks
    t1 = Thread(target=thread_cpu_bound_operations, args=(100000000, 2))
    t2 = Thread(target=thread_cpu_bound_operations, args=(20000000, 2))
    t3 = Thread(target=thread_io_bound_operations, args=(2, 1))
    t4 = Thread(target=thread_io_bound_operations, args=(2, 1))

    # Start activity -> invokes run() method
    t1.start()
    t2.start()
    t3.start()
    t4.start()

    # Block the calling thread -> Avoids continuing to run without threads being finished
    t1.join()
    t2.join()
    t3.join()
    t4.join()
```

<figure
  style={{display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center"}}
>
  <img
    src="/mediaArticles/threading-in-python/ex_8_four_threads_threading_lib.png"
    alt="Time spent by multithreaded program"
  ></img>
  <figcaption>
    <p>Times spent by multithreaded program. 4 threads, 4 I/O-bound tasks of 1s and 4 CPU-bound tasks</p>
  </figcaption>
</figure>

These were some examples to clarify the concept, now let's look at other more 
convenient ways to do this!

## ThreadPoolExecutor

A more convenient way of creating threads is the 
<a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" target="_blank">concurrent.futures</a> 
module. It provides a high-level interface for asynchronously executing callables.

The `concurrent.futures` module provides a 
<a href="https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor" target="_blank">`ThreadPoolExecutor`</a> 
object that we can use to create threads and a 
<a href="https://docs.python.org/3/library/concurrent.futures.html#processpoolexecutor" target="_blank">`ProcessPoolExecutor`</a> 
object for multiprocessing. 

As we focus on threads in this article, we will only work with `ThreadPoolExecutor`.

### 2 threads with ThreadPoolExecutor - ex9



### 2 threads with ThreadPoolExecutor - ex10